\documentclass{article}

\usepackage{graphicx}
\usepackage[spanish]{babel}

\usepackage{caption}

\usepackage{listings}
\lstdefinestyle{CStyle}{
	basicstyle=\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,
	language=C
}

\renewcommand{\lstlistingname}{Código}

\title{Programación Orientada al Rendimiento.\\Proyecto de Programación Paralela.}

\author{Grupo 81\\ \\
	Gonzalo Juarez Tello, 100467578\\
	Hodei Urigoitia Merodio, 100374256\\
	Adrián Mancera González, 100429049\\
	Gonzalo Martinez Martín, 100428963
}

\date{}

\begin{document}

\begin{figure}
	\includegraphics[width=\linewidth,height=0.7\textwidth]{resources/logo_uc3m.png}
\end{figure}
\maketitle
\newpage

\tableofcontents
\newpage

\section{Introducción.\label{intro}}
En esta parte de Programación Orientada al Rendimiento, paralelizamos
el programa simulador de fuerzas ejercidas entre objetos
en un cubo cerrado. Sobre este ejemplo estudiamos el impacto de las
estructuras de datos, los algoritmos, y las optimizaciones secuenciales
y paralelas en el rendimiento\footnote{rendimiento usado como sinónimo de
`tiempo de ejecución'.} final del programa.

Como refresco rápido repasamos primero el diseño secuencial.


En la sección \ref{opt} exploramos las optimizaciones tanto secuenciales como
paralelas que se tuvieron en cuenta. Haciendo comentarios
sobre cuales optimizaciones lograron permanecer en la versión final, cuáles no, y por qué es así.


Luego exponemos los resultados de las pruebas realizadas, los analizamos estadísticamente en la sección \ref{performance},
y cerramos con conclusiones al respecto.

\section{Diseño Original.\label{original}}
En el diseño original de este programa, ambas versiones SoA\footnote{Struct of Arrays} y AoS\footnote{Array of Structs}
son bastante similares. Por lo que consideramos que en este repaso no vale la pena discutir sus diseños por separado.


Una vez superada la inicialización de los objetos. Ambas versiones consitían en 3 loops anidados.
Un loop externo (con variable \textit{k} de manera que $0\leq{k} < {num\_iterations}$)
un loop interno que itera por todos los objetos de uno en uno usando una variable \textit{i}
($0\leq{i} < {num\_objects}$) , y un loop externo que itera por los objetos desde \textit{i}
excluyendo \textit{i} ($i+1\leq{j} < {num\_objects}$).

A lo largo de la memoria, a esta última
parte de los loops anidados con variables \textit{i} y \textit{j} le llamaremos \textbf{doble loop} ó \textbf{loop doble} ().
Su forma básica puede verse en Código \ref{doble_loop:no_striping-no_tiling}.
Es una estructura recurrente en el programa. La variable k desde el vamos no se presta a optimizar porque
necesita la verificación de colisiones antes de cada iteración (tiene una dependencia de datos total
entre una iteración y la otra). El doble loop aparece tanto en chequeo de colisiones, como en cálculo de
fuerzas resultantes de un objeto con el resto.


En cada loop doble se calculan las fuerzas resultantes de un objeto con todos los demás, se aplica la
correspondiente fuerza resultante a cada cuerpo involucrado en el cálculo, y luego se calcula la
aceleración, velocidad, y nueva posición del objeto \textit{i}. La optimización más importante de la
versión original (y la más obvia) es esta de evitar calcular dos veces la fuerza resultante entre
dos objetos. Esto resulta en un espacio de iteración triangular. Que nos es de mucho interés
a la hora de tener en cuenta optimizaciones (sección \ref{opt}). La figura \ref{fig:no_tiling} ilustra
el espacio de iteración del doble loop, así como su flujo de ejecución (indicado por las flechas).


Por último, el diseño original nunca elimina objetos, si no que
los marca. Luego en el código hay condicionales para poder
ignorar aquellos objetos marcados como eliminados.

\begin{lstlisting}[style=CStyle,label=doble_loop:no_striping-no_tiling,caption=doble loop simple.]
for (i = 0; i <= N; ++i)
	for (j = i+1; j <= N; j++)
\end{lstlisting}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.6\linewidth,height=0.6\textwidth]{resources/loop_anidado_no_tiling_505x565.png}
	\caption{espacio de iteración de $0\leq{i} < {num\_objects}$, y $i+1\leq{j} < {num\_objects}$
	cuando ${num\_objects}=5$. Las flechas marcan el flujo de ejecución del loop doble.
	delimitado por las flechas. \textit{i} en eje de abscisas, \textit{j} en eje de ordenadas.}
	\label{fig:no_tiling}
\end{figure}
%\newpage

\section{Optimizaciones.\label{opt}}

En esta sección discutimos distintas optimizaciones, su impacto en la performance,
y su impacto en los resultados. El tratar con operaciones en punto flotante, el programa
lidia con un trade-off entre precisión en los resultados y mejoras tiempo de ejecución.

\subsection{Optimizaciones secuenciales.\label{opt_seq}}
Las siguientes optimizaciones no solamente intentan mejorar la velocidad
del código de ejecución serializada. Si no también preparar al algoritmo
para poder aprovechar mejor la paralelización a nivel de tarea.

\subsubsection{Vectorización en cálculos de fuerza.\label{simd}}
El título de la subsección \ref{opt_seq} habla de optimizaciones secuenciales, pero para ser honestos,
no es tan así. El paralelismo a nivel de datos puede dar grandes mejoras de rendimiento a aplicaciones
que procesen datos de maneras similares a nuestro programa. Las distintas familias de instrucciones
\textbf{SIMD}\footnote{Single Instruction-Multiple Data} que disponen las arquitecturas x86-64 son
ejemplos de paralelismo a nivel de datos. Estas operaciones son capaces de aplicar la misma operación sobre varios
datos al mismo tiempo.

En nuestro código intentamos sacar ventaja de esto, pero la \textit{vectorización} tiene algunos requisitos.
Evitar dependencias de datos, especialmente de tipo RAW. Y ausencia de estructuras condicionales a no ser
que puedan ser tratadas como \textit{masked assignments}.


El diseño original tiene condicionales dispersos por todo el código. Como se menciona en
la sección \ref{original}, los objetos no se eliminan, se marcan, y su debe verificar su existencia.
Todo esto lo hace la función de chequeo de colisiones. Si esta función se divide en una parte de marcado
de colisiones y fusión de objetos (que no hace más que sumar objeto \textit{a} con objeto \textit{b}), y
una segunda parte donde se eliminen en una sola pasada los objetos marcados y se actualice la longitud
del array de objetos. Entonces el resto del código no necesita condicionales para verificar la existencia de objetos.


Otra restricción para que el compilador pueda vectorizar el código, es la \textit{supresión de dependencias de datos}.
En particular y como mínimo, evitar \textit{RAW} (al menos en x86-64). El cálculo de fuerzas tiene de esto en algunas
partes. Por ejemplo, el objeto en el índice del loop menos profundo \textit{i}, tiene dependencias WAW entre iteraciones.
O bien, hay dependencias RAW propias de utilizar el resultado de un cálculo almacenado en una variable, para un nuevo cálculo.


Una técnica llamada \textit{strip-mining} presentada en \ref{strip-mining} permite exponer la vectorización
del algoritmo, así como eliminar algunas dependencias WAW (convertir variables únicas en arrays). No es
la única utilidad que se le da en el código pero en esta sección es lo que nos importa.


Para lidiar con RAW, una posible solución es la de dividir un loop con RAW en 2 loops sin RAW (también
facilitado por strip-mining. Pero esto puede resultar en una pérdida de rendimiento, por lo tanto
hay que medir.


Como nota: la función para obtener raíz cuadradas no es vectorizable a no ser que se utilice una flag
del compilador que permite su aproximación por métodos numéricos. Esta estimación está bien hasta
cierto número de iteraciones y objetos donde el error que arrastra se vuelve imperdonable.


El código original no pareció incorporar muy bien las instrucciones SIMD en el cálculo de fuerzas.
Por alguna razón, incluso eliminando las dependencias de datos, el compilador se rehúsa a vectorizar
una parte caliente\footnote{parte del programa accedida con mucha frecuencia} del código, y obligarlo
con la directiva \textit{\#pragma omp simd} no termina en buenos resultados ni performance.

\subsubsection{Strip-Mining.\label{strip-mining}}
Strip-mining es una técnica que permite exponer oportunidades de vectorización al compilador, como es mencionado
en la subsección \ref{simd}. Varias veces el compilador puede llevar a cabo esta optimización por su cuenta.


También permite mejorar la localidad tanto espacial como temporal si los mismos datos son utilizados en distintas partes
del algoritmo. Este último uso es el que se le dá en la versión final del código para el cálculo de fuerzas.


Si N es el tamaño del array a recorrer, se utiliza un tamaño de \textit{stride} ó \textit{step} para que una variable \textit{ii}
tome valores $0\leq{ii}\leq N$ avanzando cada iteración el valor del step. Luego la variable \textit{i} original puede recorrer
el tamaño de \textit{stride} de uno en uno. Esto aplicado a \textit{loop doble}, lo deja expresado de como se lo ve en
Código \ref{doble_loop:striping-no_tiling}.

Es importante aclarar que strip-mining por sí solo no altera el orden de ejecución del programa. Por lo
que el gráfico de Figura \ref{fig:no_tiling} sigue aplicando.

\begin{lstlisting}[style=CStyle,label=doble_loop:striping-no_tiling,caption=doble loop con strip-mining en ambos loops.]
/* strip-mining de cabecera de loop 1 */
for (ii = 0; ii <= N; ii+=stride)
for (i = ii; i <= min(ii+stride-1, N); ++i)
	/* strip-mining de cabecera de loop 2 */
	for (jj = i+1; jj <= N; jj+=stride)
	for (j = jj; j <= min(jj+stride-1, N); j++)
\end{lstlisting}


El código final también hace uso de la técnica para evitar false-sharing, algo que se explica con mas profundidad
en \ref{strip-mining-parallel}, la sección de esta técnica en las optimizaciones paralelas.

\subsubsection{Loop-tiling en loops anidados.}

Loop-tiling es una técnica para mejorar la localidad temporal en loops anidados de
n-dimensiones\footnote{profundidad del anidado de loops}. Básicamente consiste en 2 pasos: strip-mining, y permutación loops.


Strip-mining es el primer paso para loop-tiling. Ya está cubierto en la subsección \ref{strip-mining}.


El último paso, la permutación o intercambio de loops \textit{simplemente}, consiste en cambiar las cabeceras de los bucles.
Esto es válido cuando las dependencias de datos no existen o se mantienen lexicográficamente positivas
tras el intercambio de loops.


Asumiendo que los loops son independientes (que en nuestro caso, de asumir asociatividad, lo son),
¿qué tan simple es el intercambio de loops? En un espacio de iteración cuadrado, bastante simple. Resulta
que es un poco más complicado de lo que parece. Pero de la sección \ref{original} damos por entendido que
nuestro espacio de iteración es triangular (como se lo ve en la figura \ref{fig:no_tiling}).
En un loop como el de Código \ref{doble_loop:striping-no_tiling}, nos gustaría permutar las cabeceras de manera que
\textit{ii} y \textit{jj} sean las primeras 2 cabeceras, con el loop de \textit{i} por debajo, y finalmente
el de \textit{j}. Para lograr esto hay que permutar la cabecera del loop \textit{i} con la del loop \textit{jj}.


¿Cómo implementar loop-tiling en un espacio de iteración triangular? El \textbf{modelo del poliedro} es parte
de un área de estudio que lleva bastante tiempo siendo desarrollada. Básicamente plantea que los espacios
de iteración que puedan plantearse como un \textbf{poliedro convexo}\footnote{convexo: una línea entre 2 puntos
del poliedro pasa únicamente por puntos interiores al poliedro} (como un espacio triangular) y cumplan las dependencias
de datos previamente explicadas, pueden replantearse para intercambiar cabeceras. La metodología básica consiste
plantear un sistema de inecuaciones que defina al \textbf{poliedro S} a partir de las cláusulas de los loops. Luego utilizar
algo llamado \textbf{método de eliminación de Fourier-Motzkin} para proyectar la variable a reacomodar (o sea, variable a eliminar y
reinsertar en algún momento). Tras la proyección, un sistema de inecuaciones de n-dimensiones (loop de n-variables)
queda como un sistema de m-dimensiones donde $m=n-1$. Con el método de Fourier-Motzkin se pueden eliminar progresivamente las variables,
para finalmente reinsertar las cabeceras de dichas variables eliminadas, bajo las nuevas cláusulas (inecuaciones). Este resultado
final es un nuevo sistema de inecuaciones que define un \textbf{poliedro S'} tal que \textit{S' es equivalente a S}.
Esta conversión en nuestro \textbf{doble loop} se representa como en la Figura \ref{fig:fourier_motzkin}. El código
resultante para las cabeceras es el de Código \ref{doble_loop:striping-tiling}.


Tanto el modelo del poliedro como la eliminación por método de Fourier-Motzkin, tienen utilidades más allá
de estas optimizaciones.

\begin{figure}
\begin{displaymath}
	\begin{array}{rrr}
		\left\{
			\begin{array}{r}
			ii\geq 0\\
			ii\leq n\\
			i\geq ii\\
			i\leq n\\
			i\leq ii+stride-1\\
			jj\geq i+1\\
			jj\leq n\\
			j\geq jj\\
			j\leq jj+stride-1\\
			j\leq n
			\end{array}
		\right.
		&
		\textit{se convierte en}
		&
		\left\{
			\begin{array}{r}
			ii\geq 0\\
			ii\leq n\\
			i\geq ii\\
			i\leq n\\
			i\leq ii+stride-1\\
			jj\geq ii+1\\
			jj\leq n\\
			j\geq jj\\
			j\geq i+1
			j\leq jj+stride-1\\
			j\leq n\\
			\end{array}
		\right.
	\end{array}
\end{displaymath}
	\caption{Pasaje del sistema de inecuaciones que define al poliedro \textit{S} en Código \ref{doble_loop:striping-no_tiling},
	al sistema de inecuaciones que define al poliedro \textit{S} en Código \ref{doble_loop:striping-tiling}}
	\label{fig:fourier_motzkin}
\end{figure}

\begin{lstlisting}[style=CStyle,label=doble_loop:striping-tiling,caption=doble loop con loop-tiling]
for (ii = 0; ii <= N; ii+=stride)
for (jj = i+1; jj <= N; jj+=stride)
	for (i = ii; i <= min(ii+stride-1, N); ++i)
		for (j = max(jj, i+1); j <= min(jj+stride-1, N); j++)
\end{lstlisting}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.6\linewidth,height=0.6\textwidth]{resources/loop_anidado_tiling_505x565.png}
	\caption{espacio de iteración triangular con loop-tiling cuando $N=5$ y $stride=2$. Flujo de ejecución
	delimitado por las flechas. \textit{i} en eje de abscisas, \textit{j} en eje de ordenadas.}
	\label{fig:no_tiling}
\end{figure}


Esta optimización en conjunto con vectorización (sección \ref{simd}) dieron al programa un speedup de más de x2.
Lastimosamente asumir asociatividad en las operaciones de punto flotante no pudo contener la propagación del error
para número de objetos e iteraciones grandes ($N > 4000$, $iteraciones > 250$), por lo que loop-tiling fue descartado
como optimización tanto para el cálculo de fuerzas como para el marcado de colisiones.

\subsubsection{Flags de compilador.}
Como programadores, además de jugar con el algoritmo, podemos jugar con las flags
del compilador en este trade-off de performance por precisión y viceversa.
Las flags usadas son:
\begin{itemize}
		\item -O3
		\item -fexcess-precision=fast -fno-rounding-math -fno-signaling-nans
			-fno-math-errno -fno-signed-zeros -fno-trapping-math: Optimizaciones
			sobre punto flotante que eran activadas por -ffast-math. Pero -ffast-math
			a su vez activa -funsafe-math-optimizations, la cual permite entre otras
			cosas aproximar por métodos numéricos, multiplicación por inverso, y asociatividad
			de punto flotante. Estas flags no muestran cambios en el resultado porque en su
			gran parte son para señalizar errores como por ejemplo división por cero, lo cual, si la detección
			de colisiones funciona bien, no debería pasar.
		\item march=native: optimizaciones especificas para la arquitectura que compile el programa (en el procesador
			utilizado esto resulta en vectorización por AVX y AVX512 en lugar de SSE).
\end{itemize}

\subsection{Optimizaciones con paralelismo.\label{opt_parallel}}

\subsubsection{Paralelización en cálculos de fuerza.}

\subsubsection{Uso de Strip-Mining para paralelismo.\label{strip-mining-parallel}}

\subsection{Conclusiones sobre las optimizaciones.}

\section{Diseño Final.\label{final}}
\subsection{AOS paralelo.}
\subsection{SOA paralelo.}

\section{Evaluación de Rendimiento.\label{performance}}
\subsection{Resultados obtenidos.}
\subsection{Secuencial vs. Paralelo.}
\subsection{Interpretación de resultados y pruebas.}

\section{Conclusiones Finales.\label{conclusiones}}

\end{document}
